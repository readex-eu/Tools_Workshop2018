\section{Design-Time Analysis} \label{sec:dta}
The output of readex-dyn-detect is stored in a configuration file in the \textit{xml} format. The configuration file consists of tags through which the user can provide specifications for:
\begin{itemize}
	\item Tuning parameters: Specified via the ranges (minimum, maximum, step size, and default) for two hardware parameters (CPU frequency and uncore frequency) and a system software parameter (number of OpenMP threads).
	\item Objectives: These can be the Energy, Execution Time, CPU Energy, Energy Delay Product, Energy Delay Product Squared, CPUEnergy, Total Cost of Ownership (TCO), as well as their normalized versions. The normalized versions compute the energy consumption per instruction, and can be used for applications with varying amounts of computation in a phase but no change in the phase characteristics.
	\item Energy metrics: These include the energy plugin name and associated metric names. 
	\item Search algorithm: This can be the exhaustive, random or individual search strategy. 
\end{itemize} 

DTA is performed by the Periscope Tuning Framework (PTF), which is a distributed framework consisting of the frontend, the tuning plugins, the experiment execution engine and a hierarchy of analysis agents. During DTA, PTF reads the configuration file, and calls a tuning plugin, which \todo{reference} searches the multi-dimensional space of system configurations, each of which is a tuning parameter. The tuning plugin performs one or more tuning steps, in which a user-specified search algorithm determines the set of system configurations that are evaluated. Each tuning step executes experiments to measure the effect of the system configuration on the objective. At the end of each tuning step, the plugin checks if the application should be restarted. After all the tuning steps are completed, the plugin generates tuning advice for the application.

Two new plugins, \texttt{readex\_intraphase} and the \texttt{readex\_intraphase} were developed for PTF to exploit the dynamism detected by \texttt{readex-dyn-detect}. If \texttt{readex-dyn-detect} reports inter-phase dynamism for the application, the user is advised to select the \texttt{readex\_interphase} tuning plugin. Both plugins perform Dynamic Voltage and Frequency Scaling (DVFS). However, they use different approaches for DTA, and hence, it is recommended to apply the \texttt{readex\_intraphase} tuning plugin if there is no inter-phase dynamism. Sections~\ref{sec:intra-phase} and~\ref{sec:inter-phase} describe in details the steps performed by the \texttt{readex\_intraphase} and \texttt{readex\_interphase} plugins to exploit the application dynamism.


\subsection{Intra-Phase Plugin} \label{sec:intra-phase}

PTF performs intra-phase dynamism tuning by executing \textbf{readex\_intraphase} plugin when there is no changes of the dynamic characteristics across the sequence of phases.

The plugin can be configured through the \textit{READEX configuration file} where the user can specify significant regions, objectives, system-level tuning parameters and search strategies. The significant regions of an application are produced by \textbf{readex-dyn-detect}~\cite{kumaraswamy2018design} which posses certain dynamism in different characteristics. The objective functions are used to evaluate the effect of different configurations of the tuning parameters. Different supported objective functions are absolute energy consumption, CPU energy consumption, execution time, energy delay product limiting the performance reduction due to energy tuning and total cost of ownership.  The total cost of ownership the summed up cost of the energy in addition to the execution time dependent fraction for hardware and software investment as well as maintenance costs and personnel. 

The normalized form of all the above objectives is the normalized objective value with respect to a metric, for example the number of AVX instructions. These normalized objectives are applied to the plugin that have different regions in different phases but no varying characteristics such as the computational intensity. The normlaized objective would allow to compare the objective values of phase with different number of significant regions. 

The plugin supports system-level tuning parameters such as core and uncore frequency and the number of threads as well as application tuning parameter. The ranges of different tuning parameter can also be specifed to apply for evaluation.

The plugin also allows the user to specify different search algorithms such as exhaustive, individual, random, genetic and so on. The additional parameters for each of the alogrithms can also be specified via this configuration file. 
Exhaustive search leads to the biggest number of configurations that are tested in subsequent program phases. The individual strategy reduces the number significantly since not the cross product of all tuning parameters is investigated, but the parameters are optimized independently. With the random strategy, the number of experiments can be specified. 

The tuning steps of the \textbf{readex\_intraphase} plugin are as follows:

The first tuning step of PTF is executed with the default configuration of the tuning parameter to collect the program's static information after starting the application. PTF uses a specific analysis strategy to gather program regions and runtime situations only for the first phase of the application. The measurement results are required to evaluate the objective value, for example, time and energy and stored to compare with the results of the last tuning step.

The next step is to tune ATPs as they are specifically independent of the system-level tuning parameter. The application expert can provide such kind of application specific parameters for example algorithmic choices. The detail about ATP is described in section ~\ref{sec:atp}. The plugin provides two new search strategies, \textbf{exhaustive\_atp} and \textbf{individual\_atp} to compute the optimal ATP configuration. The exhausive search space is built from the crossproduct of all valid combinations of ATPs and the idividual stratgey is computed from the domains individually. It first evaluates all valid points for the first domain. The best point from this domain remains fixed and investigates the next domain untill al the domains were explored. The search strategy then used \textbf{exhaustive\_atp} to explore the valid points of a domain. PTF uses these two search strategies to compute the optimal configuration for the given ATPs.   

The third step is the system-level parameter tuning which investigates the optimal configuration for system-level tuning paramter keeping the optimal configuration of the ATPs fixed found during the previous step. The search strategy is read from the configuration file. If no strategy us specified, the default individual search algorithm is selected on this step. The experiments are created for all possible ranges of the system-level tuning parameters. The plugin then evaluates the objective for the phase region followed by for each rts to compute the best system configuration respectively. The READEX tuning model is generated from this knowledge. 

The last step is called as the verification step which is performed by executing additional three experiments in order to check for phase variations with the results produced in the previous step. For this purpose, PTF configures RRL with the best system configuration for phase region and with the rts-specific best configuration and switches configurations dynamically.
 
\subsection{Inter-Phase Plugin} \label{sec:inter-phase}
The \texttt{readex\_interphase} plugin \todo{reference} is used for tuning applications that exhibit inter-phase dynamism, where the execution characteristics change across the sequence of phases. While the \texttt{readex\_intraphase} plugin does not consider similarities in the behavior between different phases, the \texttt{readex\_interphase} tuning plugin first groups similarly behaving phases into clusters, and then determines the best configuration for each cluster. It also determines the best configurations for the rts's of each created cluster.

The \texttt{readex\_interphase} plugin performs three tuning steps: cluster analysis, default execution and verification to first cluster the phases, then execute experiments for the default setting of the tuning parameters, and finally, verify if the theoretical savings match the actual savings incurred after switching the configurations. Sections~\ref{cluster-analysis},~\ref{default-execution} and~\ref{verification} describe the tuning steps in detail.

\subsection{Cluster Analysis} \label{cluster-analysis}
The plugin first reads the significant regions, ranges of the tuning parameters and the objectives from the READEX configuration file. It then uses the random strategy to create a user-specified number of experiments. In each experiment, the plugin measures the effect of executing a phase with a random system configuration from a uniform distribution \todo{reference} on the objective value. The plugin also requests for PAPI hardware metrics, such as the number of AVX instructions, L3 cache misses, and the number of conditional branch instructions, which are used to derive the features for clustering.

Features for clustering are selected carefully, as they have a high impact in selecting the cluster-best configuration. Since the dynamism in many applications results from the variation in the compute intensity and the number of conditional branch instructions, they were chosen as the features for clustering. The compute intensity is defined by $\frac{\#AVX Instructions}{\#L3 Cache Misses}$. The plugin first normalizes the features and the objective values for all the phases and the rts’s by a metric which is representative of the work done, such as the number of AVX instructions. It then transforms the numeric range of the features to [0,1] scale using min-max normalization.

The plugin then groups points that are closely packed together into clusters, and marks points that lie in low-density regions and have no nearby neighbors as noise using the DBSCAN (Density-Based Spatial Clustering of Applications with Noise) algorithm \todo{reference}. DBSCAN is a density based clustering algorithm, which requires the \textit{minPts} and the \textit{eps} parameters to cluster the phases. \textit{minPts} is the minimum number of points that must lie within a neighborhood to belong in a cluster, and is set to 4 \todo{reference}.\textit{eps} is the maximum distance between any two data points in the same neighborhood, and is automatically determined using the elbow method \todo{reference}. The elbow is a sharp change in the average 3-NN Euclidean distances plot, and represents the point that has the maximum distance to the line formed by the points with the minimum and maximum 3-NN distances.

The plugin then selects the best configuration for each cluster based on the normalized objective value. The cluster-best configuration represents one best configuration for all the phases of a particular cluster, and individual best configurations for the rts's in the cluster.

\subsection{Default Execution} \label{default-execution}
The tuning plugin restarts the application and generates the same number of experiments as the previous tuning step. In each experiment, the phase is executed with the default system configuration, i.e., the execution with the default parameter settings provided by the batch system for the system tuning parameters. The plugin uses the objective values obtained for the phases and the rts’s to compute the savings at the end of the tuning plugin.

\subsection{Verification} \label{verification}
The plugin restarts the application executes the same number of experiments as the previous tuning steps. In each experiment, the plugin executes the phase with the
corresponding cluster-best configuration and the rts's with their rts-specific
best configurations. Phases that were noise points in the clustering step are executed with the default configuration.

The plugin first creates a new node for each cluster, and then clones the children of the phase region of the Calling Context Graph (CCG) \todo{reference}. It stores the tuning results, including the measured objective values and the ranges of the features for the cluster in each node. Finally, the plugin computes the following three values to characterize the savings:
\begin{enumerate}
	\item Static savings for the rts's: The total improvement in the objective value with the static best configuration of the rts’s over the default across all the clusters.
	\item Dynamic savings for the rts’: The total improvement in the objective value for the rts’s with their specific best configuration over the static best across all the clusters.
	\item Static savings for the whole phase: The total improvement in the objective value for the best static configuration of the phase over the default across all the clusters.
\end{enumerate}

%The tuning model contains the list of clusters generated by the clustering algorithm, the set of phases belonging to each cluster, the ranges of the features that were used for clustering, the list of rts's that were tuned by the plugin, the scenarios into which they are classified, and the best configuration for each scenario.

