\section{Design-Time Analysis} \label{sec:dta}
The output of readex-dyn-detect~\cite{kumaraswamy2018design} is stored in a configuration file in the \textit{xml} format. The configuration file consists of tags through which the user can provide specifications for:
\begin{itemize}
	\item Tuning parameters: Specified via the ranges (minimum, maximum, step size, and default) for the CPU frequency, uncore frequency, and the number of OpenMP threads.
	\item Objectives: These can be the Energy, Execution Time, CPU Energy, Energy Delay Product, Energy Delay Product Squared, CPUEnergy, Total Cost of Ownership (TCO), as well as their normalized versions. The normalized versions compute the energy consumption per instruction, and can be used for applications with varying amounts of computation in a phase but no change in the phase characteristics.
	\item Energy metrics: These include the energy plugin name and associated metric names. 
	\item Search algorithm: This can be the exhaustive, random or individual search strategy.
\end{itemize} 

DTA is performed by the Periscope Tuning Framework (PTF), which is a distributed framework consisting of the frontend, the tuning plugins, the experiment execution engine and a hierarchy of analysis agents. During DTA, PTF reads the configuration file, and calls a tuning plugin~\cite{AutoTune:Book2015}, which searches the multi-dimensional space of system configurations, each of which is a tuning parameter. The tuning plugin performs one or more tuning steps, in which a user-specified search algorithm determines the set of system configurations that are evaluated. Each tuning step executes experiments to measure the effect of the system configuration on the objective. At the end of each tuning step, the plugin checks if the application should be restarted. After all the tuning steps are completed, the plugin generates tuning advice for the application.

Two new plugins, \texttt{readex\_intraphase} and the \texttt{readex\_interphase} were developed for PTF to exploit the dynamism detected by \texttt{readex-dyn-detect}. If \texttt{readex-dyn-detect} reports inter-phase dynamism for the application, the user is advised to select the \texttt{readex\_interphase} tuning plugin. Both plugins perform Dynamic Voltage and Frequency Scaling (DVFS). However, they use different approaches for DTA, and hence, it is recommended to apply the \texttt{readex\_intraphase} tuning plugin if there is no inter-phase dynamism. Sections~\ref{sec:intra-phase} and~\ref{sec:inter-phase} describe in details the steps performed by the \texttt{readex\_intraphase} and \texttt{readex\_interphase} plugins to exploit the application dynamism.


\subsection{Intra-Phase Plugin} \label{sec:intra-phase}

PTF performs intra-phase dynamism tuning by executing \textbf{readex\_intraphase} plugin when there is no changes of the dynamic characteristics across the sequence of phases.  

The \textbf{readex\_intraphase} plugin is executed in four tuning steps: default execution, ATP tuning, system parameter tuning and the verification step. The default exection is the computation of the objective value for the default paramter settings. Next, the ATP tuning investigates optimal settings for the given ATPs. The application is tuned with the optimal ATP settings along with the system level parameters during the system parameter tuning step. The verification step analyzes the results of the previous step and determines the best system configuration for the phase region as well as the specific best settings for the rts's.

\subsubsection{Default Execution} \label{intra-default-execution} 

During this step, PTF executes the plugin with the default configuration of the tuning parameter to collect the program's static information after starting the application. The default settings are provided by the batch system for the system parameter and the ATP specification in the code for ATPs. PTF uses a specific analysis strategy to gather program regions and runtime situations only for the first phase of the application. The measurement results are required to evaluate the objective value, for example, time and energy and stored to compare with the results of the verification step.

\subsubsection{ATP Tuning} \label{atp-tuning} 
The next step is to tune ATPs as they are specifically independent of the system-level tuning parameter. The application expert can provide such kind of application specific parameters for example algorithmic choices. The detail about ATP is described in section ~\ref{sec:atp}. 

The plugin provides two new search strategies, \textbf{exhaustive\_atp} and \textbf{individual\_atp} to compute the optimal ATP configuration. These two search strategies can also be configured via the READEX configuration file.

The \textbf{exhaustive\_atp} search space is built from the crossproduct of all valid combinations of ATPs. The plugin contacts to the ATP server to receive the valid combinations of the points for each of the given ATP domains. The configuration set   is then built from the cross products of the computed valid points. 

On the other hand, the \textbf{individual\_atp} stratgey is computed from the domains individually instead of the crossproduct of the valid points of the domains. It first evaluates all valid points for the first domain. The best point from this domain remains fixed and the next domain is investigated until all the domains were explored. The search strategy then used \textbf{exhaustive\_atp} to explore the valid points of a domain. 

\subsubsection{System Parameter Tuning} \label{sys-tuning} 
The system-level parameter tuning investigates the optimal configuration for system-level tuning paramter keeping the optimal configuration of the ATPs fixed found during the previous step. The search strategy is read from the configuration file. Exhaustive search leads to the biggest number of configurations that are tested in subsequent program phases. The individual strategy reduces the number significantly since it is not the cross product of all tuning parameters. For this search strategy the tuning parameters are optimized independently. With the random strategy, the number of experiments can be specified. If no strategy is specified, the default individual search algorithm is selected on this step. The experiments are created for all possible ranges of the system-level tuning parameters. The plugin evaluates the objective for the phase region followed by for each rts to compute the best system configuration respectively. The READEX tuning model is generated from this knowledge. 

\subsubsection{Verification} \label{intra-verification} 
The verification step is performed by executing additional three experiments in order to check for phase variations with the results produced in the previous step. For this purpose, PTF configures RRL with the best system configuration for phase region and with the rts-specific best configuration. RRL switches system configurations dynamically for the rts's. 

Finally, the plugin determines the static and dynamic savings for the rts's ans static savings for the whole phase to evaluate the tuning result and then a tuning model is precomputed. Additionally, the generated tuning model for differents inputs of an application can be merged into one general tuning model by an external \textbf{Tuning Model Merger} tool. The detail about this tool is explained in section~\ref{sec:input}.

\subsection{Computation of Savings} \label{sec:com-savings}
The plugin computes the following three values to characterize the savings at the end of the execution:
\begin{enumerate}
	\item Static savings for the rts's: The total improvement in the objective value with the static best configuration of the rts’s over the default configuration. 
	\item Dynamic savings for the rts’: The total improvement in the objective value for the rts’s with their specific best configuration over the static best configuration.
	\item Static savings for the whole phase: The total improvement in the objective value for the best static configuration of the phase over the default configuration.
\end{enumerate}
 
\subsection{Inter-Phase Plugin} \label{sec:inter-phase}
The \texttt{readex\_interphase} plugin~\cite{PDPTA_18_Kumaraswamy} is used for tuning applications that exhibit inter-phase dynamism, where the execution characteristics change across the sequence of phases. While the \texttt{readex\_intraphase} plugin does not consider similarities in the behavior between different phases, the \texttt{readex\_interphase} tuning plugin first groups similarly behaving phases into clusters, and then determines the best configuration for each cluster. It also determines the best configurations for the rts's of each created cluster.

The \texttt{readex\_interphase} plugin performs three tuning steps: cluster analysis, default execution and verification to first cluster the phases, then execute experiments for the default setting of the tuning parameters, and finally, verify if the theoretical savings match the actual savings incurred after switching the configurations. Sections~\ref{cluster-analysis},~\ref{default-execution} and~\ref{verification} describe the tuning steps in detail.

\subsubsection{Cluster Analysis} \label{cluster-analysis} 
The plugin first reads the significant regions, ranges of the tuning parameters and the objectives from the READEX configuration file. It then uses the random strategy to create a user-specified number of experiments. In each experiment, the plugin measures the effect of executing a phase with a random system configuration from a uniform distribution~\cite{AutoTune:Book2015} on the objective value. The plugin also requests for PAPI hardware metrics, such as the number of AVX instructions, L3 cache misses, and the number of conditional branch instructions, which are used to derive the features for clustering.

Features for clustering are selected carefully, as they have a high impact in selecting the cluster-best configuration. Since the dynamism in many applications results from the variation in the compute intensity and the number of conditional branch instructions, they were chosen as the features for clustering. The compute intensity is defined by $\frac{\#AVX Instructions}{\#L3 Cache Misses}$~\cite{PDPTA_18_Kumaraswamy}. The plugin first normalizes the features and the objective values for all the phases and the rts’s by a metric which is representative of the work done, such as the number of AVX instructions. It then transforms the numeric range of the features to [0,1] scale using min-max normalization.

The plugin then groups points that are closely packed together into clusters, and marks points that lie in low-density regions and have no nearby neighbors as noise using the DBSCAN (Density-Based Spatial Clustering of Applications with Noise) algorithm~\cite{Ester-1996}. DBSCAN is a density based clustering algorithm, which requires the \textit{minPts} and the \textit{eps} parameters to cluster the phases. \textit{minPts} is the minimum number of points that must lie within a neighborhood to belong in a cluster, and is set to 4~\cite{Sander-1998}.\textit{eps} is the maximum distance between any two data points in the same neighborhood, and is automatically determined using the elbow method~\cite{gaonkar2013autoepsdbscan}. The elbow is a sharp change in the average 3-NN Euclidean distances plot, and represents the point that has the maximum distance to the line formed by the points with the minimum and maximum 3-NN distances.

The plugin then selects the best configuration for each cluster based on the normalized objective value. The cluster-best configuration represents one best configuration for all the phases of a particular cluster, and individual best configurations for the rts's in the cluster.

\subsubsection{Default Execution} \label{default-execution} 
The tuning plugin restarts the application and generates the same number of experiments as the previous tuning step. In each experiment, the phase is executed with the default system configuration, i.e., the execution with the default parameter settings provided by the batch system for the system tuning parameters. The plugin uses the objective values obtained for the phases and the rts’s to compute the savings at the end of the tuning plugin.

\subsubsection{Verification} \label{verification} 
The plugin restarts the application executes the same number of experiments as the previous tuning steps. In each experiment, the plugin executes the phase with the
corresponding cluster-best configuration and the rts's with their rts-specific
best configurations. Phases that were noise points in the clustering step are executed with the default configuration.

The plugin first creates a new node for each cluster, and then clones the children of the phase region of the Calling Context Graph (CCG)~\cite{kumaraswamy2018design}. It stores the tuning results, including the measured objective values and the ranges of the features for the cluster in each node. 

\subsection{Computation of Savings}
Like the \texttt{readex\_intraphase} plugin, the \texttt{readex\_interphase} plugin computes the savings as described in Section~\ref{sec:com-savings}. However, the \texttt{readex\_interphase} plugin aggregates the improvements across all the clusters.

%The tuning model contains the list of clusters generated by the clustering algorithm, the set of phases belonging to each cluster, the ranges of the features that were used for clustering, the list of rts's that were tuned by the plugin, the scenarios into which they are classified, and the best configuration for each scenario.

