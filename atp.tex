\subsection{Application Tuning Parameters} \label{sec:atp}

<applications running on a cluster are aimed to solve numerical problems. Usually, the solutions can be computed with different methods. Among them there is numerical integration (Simpson, Gaussian Quadrature, Newton-Cotes, ...), function minimization (Gradient Descent, Conjugate Gradient Descent, Newton, ...) or finding the eigenvalues and eigenvectors of real matrices (power method, inverse power method, Arnoldi, ...). These methods may have different implementations, like the Fast Fourier Transform (algorithms from Cooley-Tukey, Bruun, Rader, Bluestein) implemented in the FFTW, FFTS, FFTPACK or MKL.

For a given problem, several methods can provide similar numerical solution through different implementations. In HPC, the developer chooses the most efficient in term of numerical accuracy and time to solution. However, this later also depends on the computer's architecture. For example some methods can be more efficient on a vector processor than on a superscalar processor. It is up to the application's developer to chose the appropriate method and its implementation that fulfill the computer's specificity.


In the context of the energy saving, the energy consumption must also be minimized. It makes it hard for the developer to choose which method and implementation must be executed. READEX offers the developer to expose the various methods and their implementation via Application Tuning Parameters (ATP) to the tuning process. ATPs are communicated to READEX through an API used to annotate the source code at locations where the tuning parameters play a role.

\begin{figure}
\centering
\includegraphics[width=0.8\columnwidth]{figures/overall_design.pdf} 
\caption{Workflow handling ATPs in READEX. }
\label{fig_ATP_workflow}
\end{figure} 

Figure~\ref{fig_ATP_workflow} illustrates the step in tuning ATPs. First, ATPs are declared in the code through annotations. The application is then linked agains the ATPlibrary implementing the annotation API. During DTA, first the ATP description file is generated from the ATPlibrary. This file includes the tuning parameters with their specification and is used to define the search space. The intraphase tuning plugin was extended to also search this space to find the best settings for the ATPs. Finally the best configurations are also stored in the ATM and passed to RAT.

The application developer exposes control variables and mark them as ATPs with the API functions as illustrated in Listing~\ref{lbl:atp_declare}. The function \texttt{ATP\_PARAM\_DECLARE} declares the parameter's name, type, default value and domain. The function \texttt{ATP\_PARAM\_ADD\_VALUES} allows to add possible values the parameter can take, in a range specified by minimal, maximal and increment values; or by enumerating explicitly the possible values. The function \texttt{ATP\_PARAM\_GET} fetches the value given in the ATM from the RRL and assigns it to the control variable. 

Several ATPs can be defined in the same code. They may be independent or not. In the latter case, there is a notion of constraints between the parameters. To indicate to READEX that parameters have constraints between them, these parameters are put in the same \texttt{domain\_name}.


	\definecolor{mygray}{rgb}{0.46,0.46,0.46}
	\lstset{language=[90]Fortran,
		%	basicstyle=\ttfamily,
		frame=lines,
		xleftmargin=\parindent,
		aboveskip=2mm,
		belowskip=2mm,
		showstringspaces=false,
		columns=flexible,
		breaklines=true,
		breakatwhitespace=true,
		keywordstyle=\color{blue},
		commentstyle=\color{mygray},
		numbers=left,
		numberstyle=\tiny\color{mygray},
		numbersep=1em,
		escapeinside={(@*}{*@)},
	}
\todo{somehow, the listing has no number. why?}

\begin{multicols}{2}[\captionof{lstlisting}{ATP constraint and exploration declaration with the ATP library.}] \label{lbl:atp_example}
\begin{lstlisting}[language=C,xleftmargin=3em,frame=none,title=\phantom{xxx}]
void foo(){
  int atp_cv;
  ...
  ATP_PARAM_DECLARE("solver", RANGE, 1, "DOM1");
  int32_t solver_values[3] = {1,5,1};
  ATP_ADD_VALUES("solver", solver_values, 3, "DOM1");
  ATP_PARAM_GET("solver", &atp_cv, "DOM1");
	
  switch (atp_cv){
  case 1:
    // choose solver 1
    break;
  case 2:
    // choose solver 2
    break;
    ...
  }
  int32_t hint_array = {GENETIC, RANDOM};
  ATP_EXPLORATION_DECLARE(hint_array, "DOM1");
}
	
void bar(){
  int atp_ms;
  ...
  ATP_PARAM_DECLARE("mesh", RANGE, 40, "DOM1");
  int32_t mesh_values[3] = {0,80,10};
  ATP_ADD_VALUES("mesh", mesh_values, 3, "DOM1");
  ATP_PARAM_GET("mesh", &atp_ms, "DOM1");
  ATP_CONSTRAINT_DECLARE("const1", "(solver = 1 && 0 <= mesh <= 40) || (solver = 2 && 40 <= mesh <= 80) || (solver > 2 && mesh = 120)", "DOM1");
  if((atp_ms > 1) && (atp_ms <= 40)){
    // choose mesh size 1
  }
  if((atp_ms > 40) && (atp_ms <= 80)){
    // choose mesh size 2
  }
  if(atp_ms == 120){
    // choose mesh size 3
  }
}
\end{lstlisting}
\end{multicols}

Once the source code is annotated and the compiled code is executed, the ATP library generates a description file in which the ATPs are written. This file contains the details about the declared application parameters.

During DTA, PTF launches the ATP server that reads the ATP description file. The ATP server's task is to respond to PTF requests, such as providing the list of ATPs or a list of valid values of ATPs. The \texttt{readex\_intraphase} tuning plugin uses the list of valid values to generate a search space of the tuning parameters (not only the ATPs) and explore it. The resulting tuning model also consists of the best combination of the ATPs.

The plugin provides two new search strategies, \texttt{exhaustive\_atp} and \linebreak[4]\texttt{individual\_atp} to compute the optimal ATP configuration. These two search strategies can also be configured via the READEX configuration file.

The \texttt{exhaustive\_atp} search space is built from the crossproduct of all valid combinations of ATPs. The plugin contacts to the ATP server to receive the valid combinations of the points for each of the given ATP domains. The configuration set is then built from the cross products of the computed valid points. 

On the other hand, the \texttt{individual\_atp} strategy tunes the domains individually. It first evaluates all valid points for the first domain. The best point from this domain remains fixed and the next domain is investigated until all the domains were explored.  

The tuning of ATPs is done before the tuning of the frequencies and the threads since it determines the algorithm to be used during execution. This algorithm is then tuned in subsequent tuning steps of the intraphase tuning plugin with respect to the system and runtime parameters. 

The configuration of ATPs is finally passed to RAT through the ATM as any other tuning parameter. At runtime, the optimal value is read through the ATPlibrary in combination with the RRL and is assigned to the control variable.
